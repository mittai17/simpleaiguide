---
interface Props {
    count?: number;
}

const { count = 40 } = Astro.props;
---

<canvas
    id="starfield"
    data-count={count}
    class="absolute inset-0 w-full h-full -z-10 opacity-50 pointer-events-none"
></canvas>

<script>
    const canvas = document.getElementById("starfield") as HTMLCanvasElement;
    const ctx = canvas.getContext("2d");

    if (canvas && ctx) {
        // Read count from data attribute or default to 40
        const count = parseInt(canvas.dataset.count || "40", 10);

        let lastWidth = window.innerWidth;

        const resize = () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;

            // On mobile, scrolling often triggers resize due to URL bar hiding/showing.
            // We only want to reset stars if the width changes (orientation change)
            // or if the height change is significant (e.g. strict resize),
            // avoiding jarring resets during scroll.
            if (newWidth !== lastWidth) {
                width = newWidth;
                height = newHeight;
                canvas.width = width;
                canvas.height = height;
                lastWidth = newWidth;
                initStars();
            } else {
                // Just update dimensions without resetting stars if only height changed slightly
                // or update canvas buffer size to match visual size to prevent scaling artifacts
                if (Math.abs(canvas.height - newHeight) > 100) {
                    height = newHeight;
                    canvas.height = height;
                    // We might lose stars at the bottom or have empty space,
                    // but better than full reset.
                    // Ideally we'd re-map stars, but skipping initStars is smoother.
                }
            }
        };

        const initStars = () => {
            stars = [];
            for (let i = 0; i < count; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: Math.random() * 2,
                    speed: Math.random() * 0.5 + 0.1,
                });
            }
        };

        const animate = () => {
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = "#94a3b8";

            stars.forEach((star) => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();

                star.y -= star.speed;
                if (star.y < 0) {
                    star.y = height;
                    star.x = Math.random() * width;
                }
            });

            requestAnimationFrame(animate);
        };

        window.addEventListener("resize", resize);
        // Initial setup
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        initStars();
        animate();
    }
</script>
